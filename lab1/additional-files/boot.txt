	JOS: Explicação detalhada do boot até o carregamento do kernel

			Luiz Fernando N. Capitulino
			   lcapitulino@gmail.com

1. Introdução
-------------

 Este documento explica a sequência de incialização do PC, baseando-se no
emulador bochs e no kernel do curso de sistemas operacionais do MIT (JOS).

2. Modos de operação
--------------------

FIXME: Descrever modos de operação

2.1 Modo real
-------------

 Quando o PC é ligado o processador está em um modo de operação conhecido
como 'modo real'. Neste modo o processador é um genuíno Intel 8086, o
primeiro processador da família x86.

 As características mais importantes do modo real são:

 o Barramento de dados e registradores de propósito geral de 16-bits
   (ie, processador de 16-bits)
 o Barramento de endereçamento de 20-bits, então endereça até 1MB de RAM
   (0x00000 - 0xFFFFF)
 o Limite de 640KB de RAM. O intervalo de 640KB-1MB é mapeado para outros
   usos (display VGA, ROMs de expansão e BIOS)

 O processador inicia em modo real para manter compatibilidade com os
softwares que foram escritos para o 8086 e 8088.

2.2 Modo protegido
------------------

FIXME: Descrever

3. BIOS
-------

 Logo quando é ligado, o processador (simulado pelo bochs) carrega o
registrador CS (Code Segment) com o valor 0xF000 e o IP (Instruction Pointer)
com 0xFFF0. Isso significa que o processador começa executando o código
contido no endereço físico 0x000FFFF0.

 Esse endereço está dentro da área de memória da BIOS, que vai de 0x000F0000
até 0x00100000 (o hardware do PC mapeia esse intervalo para a memória flash
que contêm a BIOS), mas 0x000FFFF0 é o final da região de memória da BIOS,
restam apenas 16 bytes para acabar o espaço.

 Então a primeira instrução que o código da BIOS do bochs executa é um salto
para o começo da região da área de memória da BIOS:

(0) [0xfffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b         ; ea5be000f0

 Dessa maneira, o código da BIOS fica com um intervalo maior.

 A BIOS executa, e suas tarefas mais importantes são:

 o Fazer testes de consistência e inicializar vários dispositivos
 o Configurar dispositivos PCI
 o Verificar a quantidade de memória disponível no sistema
 o Carregar o código do boot loader e executá-lo

 O último ítem é também o último procedimento que a BIOS executa. Ela procura
por um dispositivo de boot (disco rígido ou disquete, normalmente configurado
pelo usuário) e carrega seu primeiro setor (512 bytes) no intervalor de
endereço físico 0x00007C00-0x00007DFF e, usando a instrução jmp, pula para
este endereço, transferindo o controle para o boot loader.

FIXME: Falar sobre boot em CD-ROM.

4. Boot Loader
--------------

 O objetivo do boot loader é carregar o kernel do disco rígido (ou da mídia
em que ele estiver armazenado) e transferir o controle para ele.

 O boot loader do JOS é muito simples, ele é escrito em linguagem assembly
e C.

 O código em assembly executa as seguintes operações:

 1. Desabilita interruções
 2. Coloca 0 nos registradores de segmento
 3. Configura a pilha
 4. Habilita a linha A20 para poder endereçar 1MB de memória em mode real
 5. Entra em modo protegido
 6. Pula para o código em C

 A GDT usada para o modo protegido cria dois segmentos, o de código e o
segmento de dados. Ambos tem base 0 e limite de 4GB, o que significa que
toda a memória disponível no computador pode ser endereçada.

 O código em C do boot loader é igualmente simples, tudo o que ele faz é
carregar o kernel do disco e chamar o entry point do cabeçalho ELF.

 O kernel é carregado no endereço 0x0010000, e tanto a informação do tamanho
do kernel quanto o entry point (ie, o código que deve começar a ser
executado) são lidas do cabeçalho ELF.

FIXME: Falar sobre outros boot loaders (grub e lilo)

5. Kernel
---------

 A primeira parte do código do kernel está em assembly, e esse código
tem que configurar o ambiente para que o código do kernel possa ser
executado.

 A configuração mais importante que esse código faz é configurar uma
outra GDT, essa GDT vai ter o mapeamento necessário para executar o código
do kernel, isto é, o endereço de ligamento do código do kernel é 0xF0100000
mas o kernel é carregado no endereço 0x00100000.

 O que essa GDT faz é mapear todos os endereços gerados pelo kernel para
o endereço onde o kernel realmente foi carregado.

 Por exemplo, digamos que o kernel gere o código 0xF0100007, essa mapeamento
vai fazer com que o processador acesse o endereço 0x00100007.

FIXME: Escrever exemplo detalhado
