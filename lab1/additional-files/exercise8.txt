Exercise 8:
-----------

Q1: Use Bochs to trace into the JOS kernel, and identify the exact point at
which the new virtual-to-physical mapping takes effect. Then examine the
Global Descriptor Table (GDT) that the code uses to achieve this effect,
and make sure you understand what's going on.

 The new virtual-to-physical mapping will take effect at this instruction:

(0) [0x00100015] 0008:00100015 (unk. ctxt): lgdt ds:0x10f018          ; 0f011518f01000

which corresponds to this instruction in kern/entry.S:

lgdt    RELOC(mygdtdesc)                # load descriptor table

(But all the segment registers must be reloaded to get its 'hidden part'
updated with the new segment descriptor's info).

 The new GDT will create two segments (data and code) with the following
range:

Base: -0xF0000000
Limit: 0xFFFFFFFF

 This will give the desired mapping: the kernel was loaded at 0x00100000 but
its linker address is 0xF0100000.

 By having a linker address of 0xF0100000 all the address generated by the
kernel (eg, functions' addresses) will have its memory position calculated
from 0xF0100000.

 By using the new GDT, all the addresses the kernel tries to access will get
the segment descriptor's base address added to it.

 For example, the following code:

f0100038:       e8 fd 00 00 00          call   f010013a <i386_init>

 will generate a call to 0xF010013A. But the processor will add that
address to the code segment descriptor's base, which is -0xF0000000,
to form the linear address. The result will be 0x0010013A, which is where
the code actually is.


Q2: What is the first instruction after this point that would fail to
work properly if this virtual-to-physical mapping wasn't in place?

 The first instruction that would fail is this one:

ljmp    $CODE_SEL,$relocated            # reload CS by jumping

'relocated's virtual address is 0xF010002e, it must be mapped to the linear
address 0x0010002E, because it's where the 'relocated's code is.

 So, if we change the virtual-to-physical mapping to a wrong value
(ie, any value which doesn't map 0xF010002e to 0x0010002E) that instruction
will jump to a wrong location.
